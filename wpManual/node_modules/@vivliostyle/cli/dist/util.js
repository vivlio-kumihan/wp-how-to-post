import AjvModule from 'ajv';
import AjvFormatsModule from 'ajv-formats';
import betterAjvErrors from 'better-ajv-errors';
import chalk from 'chalk';
import debugConstructor from 'debug';
import fastGlob from 'fast-glob';
import { XMLParser } from 'fast-xml-parser';
import { globby } from 'globby';
import gitIgnore from 'ignore';
import StreamZip from 'node-stream-zip';
import fs from 'node:fs';
import { fileURLToPath } from 'node:url';
import util from 'node:util';
import oraConstructor from 'ora';
import portfinder from 'portfinder';
import slash from 'slash';
import tmp from 'tmp';
import { copy, copySync, move, moveSync, remove, removeSync, upath, } from '../vendors/index.js';
import { publicationSchema, publicationSchemas } from './schema/pubManifest.js';
import { vivliostyleConfigSchema } from './schema/vivliostyle.js';
export { copy, copySync, move, moveSync, remove, removeSync, upath };
export const debug = debugConstructor('vs-cli');
export const cwd = upath.normalize(process.cwd());
const ora = oraConstructor({
    color: 'blue',
    spinner: 'circle',
    // Prevent stream output in docker so that not to spawn process
    // In other environment, check TTY context
    isEnabled: checkContainerEnvironment() ? false : undefined,
});
export let beforeExitHandlers = [];
export function runExitHandlers() {
    while (beforeExitHandlers.length) {
        try {
            beforeExitHandlers.shift()?.();
        }
        catch (e) {
            // NOOP
        }
    }
}
const exitSignals = ['exit', 'SIGINT', 'SIGTERM', 'SIGHUP'];
exitSignals.forEach((sig) => {
    process.on(sig, (code) => {
        runExitHandlers();
        process.exit(code);
    });
});
/**
 * 0: silent
 * 1: info
 * 2: verbose
 * 3: debug
 */
let logLevel = 0;
export function setLogLevel(level) {
    if (!level) {
        return;
    }
    logLevel = {
        silent: 0,
        info: 1,
        verbose: 2,
        debug: 3,
    }[level];
    if (logLevel >= 3) {
        debugConstructor.enable('vs-cli');
    }
}
/**
 * @returns A function that stops logging
 */
export function startLogging(text) {
    if (logLevel < 1) {
        return () => { };
    }
    // If text is not set, erase previous log with space character
    ora.start(text ?? ' ');
    return stopLogging;
}
/**
 * @returns A function that starts logging again
 */
export function suspendLogging(text, symbol) {
    if (logLevel < 1) {
        return () => { };
    }
    const { isSpinning, text: previousLoggingText } = ora;
    stopLogging(text, symbol);
    return (text) => {
        isSpinning ? startLogging(text || previousLoggingText) : ora.info(text);
    };
}
// NOTE: This function is intended to be used in conjunction with startLogging function,
// so it is not intentionally exported.
function stopLogging(text, symbol) {
    if (logLevel < 1) {
        return;
    }
    if (!text) {
        ora.stop();
        return;
    }
    ora.stopAndPersist({ text, symbol });
}
export function log(...obj) {
    if (logLevel < 1) {
        return;
    }
    console.log(...obj);
}
export function logUpdate(...obj) {
    if (logLevel < 1) {
        return;
    }
    if (ora.isSpinning) {
        ora.text = obj.join(' ');
    }
    else {
        ora.info(obj.join(' '));
    }
}
export function logSuccess(...obj) {
    if (logLevel < 1) {
        return;
    }
    const { isSpinning, text } = ora;
    ora.succeed(obj.join(' '));
    if (isSpinning) {
        startLogging(text);
    }
}
export function logError(...obj) {
    if (logLevel < 1) {
        return;
    }
    const { isSpinning, text } = ora;
    ora.fail(obj.join(' '));
    if (isSpinning) {
        startLogging(text);
    }
}
export function logWarn(...obj) {
    if (logLevel < 1) {
        return;
    }
    const { isSpinning, text } = ora;
    ora.warn(obj.join(' '));
    if (isSpinning) {
        startLogging(text);
    }
}
export function logInfo(...obj) {
    if (logLevel < 1) {
        return;
    }
    const { isSpinning, text } = ora;
    ora.info(obj.join(' '));
    if (isSpinning) {
        startLogging(text);
    }
}
export class DetailError extends Error {
    detail;
    constructor(message, detail) {
        super(message);
        this.detail = detail;
    }
}
export function gracefulError(err) {
    const message = err instanceof DetailError
        ? `${chalk.red.bold('Error:')} ${err.message}\n${err.detail}`
        : err.stack
            ? err.stack.replace(/^Error:/, chalk.red.bold('Error:'))
            : `${chalk.red.bold('Error:')} ${err.message}`;
    if (ora.isSpinning) {
        ora.fail(message);
    }
    else {
        console.error(message);
    }
    console.log(chalk.gray(`
If you think this is a bug, please report at https://github.com/vivliostyle/vivliostyle-cli/issues`));
    process.exit(1);
}
// Filter errors for human readability
// ref. https://github.com/atlassian/better-ajv-errors/issues/76
export function filterRelevantAjvErrors(allErrors) {
    function split(items, splitFn) {
        return [items.filter(splitFn), items.filter((error) => !splitFn(error))];
    }
    function removeShadowingErrors(singleErrors, metaErrors) {
        return singleErrors.filter((error) => {
            if (metaErrors.some((metaError) => error.instancePath.startsWith(metaError.instancePath))) {
                return !singleErrors.some((otherError) => otherError.instancePath.startsWith(error.instancePath) &&
                    otherError.instancePath.length > error.instancePath.length);
            }
            else {
                return true;
            }
        });
    }
    function mergeTypeErrorsByPath(typeErrors) {
        const typeErrorsByPath = typeErrors.reduce((acc, error) => {
            const key = error.instancePath;
            return {
                ...acc,
                [key]: [...(acc[key] ?? []), error],
            };
        }, {});
        return Object.values(typeErrorsByPath).map(mergeTypeErrors);
        function mergeTypeErrors(typeErrors) {
            const params = {
                type: typeErrors.map((error) => error.params.type).join(','),
            };
            return {
                ...typeErrors[0],
                params,
            };
        }
    }
    const META_SCHEMA_KEYWORDS = Object.freeze(['anyOf', 'allOf', 'oneOf']);
    // Split the meta errors from what I call "single errors" (the real errors)
    const [metaErrors, singleErrors] = split(allErrors, (error) => META_SCHEMA_KEYWORDS.includes(error.keyword));
    // Filter out the single errors we want to show
    const nonShadowedSingleErrors = removeShadowingErrors(singleErrors, metaErrors);
    // We're handling type errors differently, split them out
    const [typeErrors, nonTypeErrors] = split(nonShadowedSingleErrors, (error) => error.keyword === 'type');
    // Filter out the type errors that already have other errors as well.
    // For example when setting `logLevel: 4`, we don't want to see the error specifying that logLevel should be a string,
    // if the other error already specified that it should be one of the enum values.
    const nonShadowingTypeErrors = typeErrors.filter((typeError) => !nonTypeErrors.some((nonTypeError) => nonTypeError.instancePath === typeError.instancePath));
    const typeErrorsMerged = mergeTypeErrorsByPath(nonShadowingTypeErrors);
    return [...nonTypeErrors, ...typeErrorsMerged];
}
export function readJSON(path) {
    try {
        return JSON.parse(fs.readFileSync(path, 'utf8'));
    }
    catch (err) {
        return undefined;
    }
}
export function statFileSync(filePath, { errorMessage = 'Specified input does not exist', } = {}) {
    try {
        return fs.statSync(filePath);
    }
    catch (err) {
        if (err.code === 'ENOENT') {
            throw new Error(`${errorMessage}: ${filePath}`);
        }
        throw err;
    }
}
export async function inflateZip(filePath, dest) {
    return await new Promise((res, rej) => {
        try {
            const zip = new StreamZip({
                file: filePath,
                storeEntries: true,
            });
            zip.on('error', (err) => {
                rej(err);
            });
            zip.on('ready', async () => {
                await util.promisify(zip.extract)(null, dest);
                await util.promisify(zip.close)();
                debug(`Unzipped ${filePath} to ${dest}`);
                res();
            });
        }
        catch (err) {
            rej(err);
        }
    });
}
export function useTmpDirectory() {
    return new Promise((res, rej) => {
        tmp.dir({ unsafeCleanup: true }, (err, path, clear) => {
            if (err) {
                return rej(err);
            }
            debug(`Created the temporary directory: ${path}`);
            const callback = () => {
                // clear function doesn't work well?
                // clear();
                removeSync(path);
                debug(`Removed the temporary directory: ${path}`);
            };
            beforeExitHandlers.push(callback);
            res([path, callback]);
        });
    });
}
export async function touchTmpFile(path) {
    fs.mkdirSync(upath.dirname(path), { recursive: true });
    // Create file if not exist
    fs.closeSync(fs.openSync(path, 'a'));
    debug(`Created the temporary file: ${path}`);
    const callback = () => {
        removeSync(path);
        debug(`Removed the temporary file: ${path}`);
    };
    beforeExitHandlers.push(callback);
    return callback;
}
export function pathEquals(path1, path2) {
    return upath.relative(path1, path2) === '';
}
export function pathContains(parentPath, childPath) {
    const rel = upath.relative(parentPath, childPath);
    return rel !== '' && !rel.startsWith('..');
}
export function isUrlString(str) {
    return /^(https?|file|data):/i.test(str);
}
export function findAvailablePort() {
    portfinder.basePort = 13000;
    return portfinder.getPortPromise();
}
export function checkContainerEnvironment() {
    return fs.existsSync('/opt/vivliostyle-cli/.vs-cli-version');
}
// Mostly the same as the globby implementation, with some overrides
// for ignorefile lookups to avoid circular references by symbolic links
export async function safeGlob(patterns, options) {
    const symbolicLinkSet = new Set();
    const customFs = {
        readdir: function customReaddir(filepath, options, callback) {
            return fs.readdir(filepath, options, (err, files) => {
                if (err) {
                    callback(err, files);
                    return;
                }
                const filtered = files.filter((dirent) => {
                    if (!dirent.isSymbolicLink()) {
                        return true;
                    }
                    const dirpath = upath.join(filepath, dirent.name);
                    // Omit nested symbolic link from readdir result and avoid cyclic exploring
                    if ([...symbolicLinkSet].some((v) => pathContains(v, dirpath))) {
                        return false;
                    }
                    symbolicLinkSet.add(dirpath);
                    return true;
                });
                callback(null, filtered);
            });
        },
    };
    const parseIgnoreFile = (file, cwd) => {
        const base = slash(upath.relative(cwd, upath.dirname(file.filePath)));
        return file.content
            .split(/\r?\n/)
            .filter((line) => line && !line.startsWith('#'))
            .map((pattern) => pattern.startsWith('!')
            ? `!${upath.posix.join(base, pattern.slice(1))}`
            : upath.posix.join(base, pattern));
    };
    const getIgnoreFilter = async () => {
        const filePatterns = [
            ...[options.ignoreFiles ?? []].flat(),
            options.gitignore ? '**/.gitignore' : [],
        ].flat();
        if (filePatterns.length === 0) {
            return () => true;
        }
        const cwd = options.cwd instanceof URL
            ? fileURLToPath(options.cwd)
            : options.cwd || process.cwd();
        const paths = await fastGlob(filePatterns, {
            cwd,
            fs: customFs,
            ignore: ['**/node_modules', '**/flow-typed', '**/coverage', '**/.git'],
            absolute: true,
            dot: true,
        });
        const files = await Promise.all(paths.map(async (filePath) => ({
            filePath,
            content: await fs.promises.readFile(filePath, 'utf8'),
        })));
        const patterns = files.flatMap((file) => parseIgnoreFile(file, cwd));
        const ignores = gitIgnore().add(patterns);
        const toRelativePath = (pwttern, cwd) => {
            cwd = slash(cwd);
            if (upath.isAbsolute(pwttern)) {
                if (slash(pwttern).startsWith(cwd)) {
                    return upath.relative(cwd, pwttern);
                }
                throw new Error(`Path ${pwttern} is not in cwd ${cwd}`);
            }
            return pwttern;
        };
        return (pattern) => {
            pattern = toRelativePath(pattern, cwd);
            return !ignores.ignores(slash(pattern));
        };
    };
    const [filter, result] = await Promise.all([
        getIgnoreFilter(),
        globby(patterns, {
            ...options,
            gitignore: false,
            ignoreFiles: [],
            fs: customFs,
        }),
    ]);
    return result.filter(filter);
}
export async function openEpubToTmpDirectory(filePath) {
    const [tmpDir, deleteEpub] = await useTmpDirectory();
    await inflateZip(filePath, tmpDir);
    const containerXmlPath = upath.join(tmpDir, 'META-INF/container.xml');
    const xmlParser = new XMLParser({
        ignoreAttributes: false,
    });
    const { container } = xmlParser.parse(fs.readFileSync(containerXmlPath, 'utf8'));
    const rootfile = [container.rootfiles.rootfile].flat()[0]; // Only supports a default rendition
    const epubOpfPath = upath.join(tmpDir, rootfile['@_full-path']);
    return { dest: tmpDir, epubOpfPath, deleteEpub };
}
// FIXME: https://github.com/ajv-validator/ajv/issues/2047
const Ajv = AjvModule.default;
const addFormats = AjvFormatsModule.default;
const getValidatorFunction = (schema, refSchemas) => (obj, errorFormatOption) => {
    const ajv = new Ajv({ strict: false });
    addFormats(ajv);
    if (refSchemas) {
        ajv.addSchema(refSchemas);
    }
    const validate = ajv.compile(schema);
    const valid = validate(obj);
    if (!valid) {
        const detailMessage = validate.errors &&
            betterAjvErrors(schema, obj, filterRelevantAjvErrors(validate.errors), errorFormatOption);
        throw detailMessage || new Error();
    }
    return true;
};
export const assertVivliostyleConfigSchema = getValidatorFunction(vivliostyleConfigSchema);
export const assertPubManifestSchema = getValidatorFunction(publicationSchema, publicationSchemas);
//# sourceMappingURL=util.js.map