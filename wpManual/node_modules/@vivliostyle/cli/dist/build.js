import chalk from 'chalk';
import { pathToFileURL } from 'node:url';
import terminalLink from 'terminal-link';
import { getExecutableBrowserPath } from './browser.js';
import { collectVivliostyleConfig, mergeConfig, } from './input/config.js';
import { exportEpub } from './output/epub.js';
import { buildPDF, buildPDFWithContainer } from './output/pdf.js';
import { copyWebPublicationAssets, prepareWebPublicationDirectory, retrieveWebbookEntry, supplyWebPublicationManifestForWebbook, } from './output/webbook.js';
import { checkOverwriteViolation, cleanupWorkspace, compile, copyAssets, prepareThemeDirectory, } from './processor/compile.js';
import { teardownServer } from './server.js';
import { checkContainerEnvironment, cwd, debug, log, runExitHandlers, setLogLevel, startLogging, upath, useTmpDirectory, } from './util.js';
export async function getFullConfig(cliFlags) {
    const loadedConf = await collectVivliostyleConfig(cliFlags);
    const { vivliostyleConfig, vivliostyleConfigPath } = loadedConf;
    const loadedCliFlags = loadedConf.cliFlags;
    const context = vivliostyleConfig
        ? upath.dirname(vivliostyleConfigPath)
        : cwd;
    const configEntries = [];
    for (const entry of vivliostyleConfig ?? [vivliostyleConfig]) {
        const config = await mergeConfig(loadedCliFlags, entry, context);
        checkUnsupportedOutputs(config);
        // check output path not to overwrite source files
        for (const target of config.outputs) {
            checkOverwriteViolation(config, target.path, target.format);
        }
        configEntries.push(config);
    }
    return configEntries;
}
export async function build(cliFlags) {
    setLogLevel(cliFlags.logLevel);
    if (cliFlags.bypassedPdfBuilderOption) {
        const option = JSON.parse(cliFlags.bypassedPdfBuilderOption);
        // Host doesn't know browser path inside of container
        option.executableBrowser = getExecutableBrowserPath(option.browserType ?? 'chromium');
        debug('bypassedPdfBuilderOption', option);
        const stopLogging = startLogging();
        await buildPDF(option);
        // Stop remaining stream output and kill process
        stopLogging();
        teardownServer();
        return;
    }
    const isInContainer = checkContainerEnvironment();
    const stopLogging = startLogging('Collecting build config');
    const configEntries = await getFullConfig(cliFlags);
    for (const config of configEntries) {
        // build artifacts
        if (config.manifestPath) {
            await cleanupWorkspace(config);
            await prepareThemeDirectory(config);
            await compile(config);
            await copyAssets(config);
        }
        // generate files
        for (const target of config.outputs) {
            let output = null;
            const { format } = target;
            if (format === 'pdf') {
                if (!isInContainer && target.renderMode === 'docker') {
                    output = await buildPDFWithContainer({
                        ...config,
                        input: (config.manifestPath ??
                            config.webbookEntryUrl ??
                            config.epubOpfPath),
                        target,
                    });
                }
                else {
                    output = await buildPDF({
                        ...config,
                        input: (config.manifestPath ??
                            config.webbookEntryUrl ??
                            config.epubOpfPath),
                        target,
                    });
                }
            }
            else if (format === 'webpub' || format === 'epub') {
                const { manifestPath, webbookEntryUrl } = config;
                let outputDir;
                if (format === 'webpub') {
                    outputDir = target.path;
                    await prepareWebPublicationDirectory({ outputDir });
                }
                else if (format === 'epub') {
                    [outputDir] = await useTmpDirectory();
                }
                else {
                    continue;
                }
                let entryContextUrl;
                let entryHtmlFile;
                let manifest;
                if (manifestPath) {
                    entryContextUrl = pathToFileURL(manifestPath).href;
                    manifest = await copyWebPublicationAssets({
                        ...config,
                        input: config.workspaceDir,
                        outputDir,
                        manifestPath,
                    });
                    if (config.input.format === 'markdown') {
                        const entry = [manifest.readingOrder].flat()[0];
                        if (entry) {
                            entryHtmlFile = upath.join(outputDir, typeof entry === 'string' ? entry : entry.url);
                        }
                    }
                }
                else if (webbookEntryUrl) {
                    const ret = await retrieveWebbookEntry({
                        webbookEntryUrl,
                        outputDir,
                    });
                    entryContextUrl = webbookEntryUrl;
                    entryHtmlFile = ret.entryHtmlFile;
                    manifest =
                        ret.manifest ||
                            (await supplyWebPublicationManifestForWebbook({
                                ...config,
                                entryHtmlFile: ret.entryHtmlFile,
                                outputDir,
                            }));
                }
                else {
                    continue;
                }
                if (format === 'epub') {
                    await exportEpub({
                        webpubDir: outputDir,
                        entryHtmlFile,
                        entryContextUrl,
                        manifest,
                        target: target.path,
                        epubVersion: target.version,
                    });
                }
                output = target.path;
            }
            if (output) {
                const formattedOutput = chalk.bold.green(upath.relative(cwd, output));
                log(`\n${terminalLink(formattedOutput, 'file://' + output, {
                    fallback: () => formattedOutput,
                })} has been created.`);
            }
        }
        teardownServer();
    }
    runExitHandlers();
    stopLogging('Built successfully.', 'ðŸŽ‰');
}
function checkUnsupportedOutputs({ epubOpfPath, outputs }) {
    if (epubOpfPath && outputs.some((t) => t.format === 'webpub')) {
        throw new Error('Exporting webpub format from EPUB or OPF file is not supported.');
    }
    if (epubOpfPath && outputs.some((t) => t.format === 'epub')) {
        throw new Error('Exporting EPUB format from EPUB or OPF file is not supported.');
    }
}
//# sourceMappingURL=build.js.map